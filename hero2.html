<!-- A-Frame + AR.js -->
<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.4/aframe/build/aframe-ar.js"></script>

<body style="margin:0; overflow:hidden">
  <a-scene
    embedded
    vr-mode-ui="enabled: false"
    renderer="logarithmicDepthBuffer: true"
    arjs="sourceType: webcam; debugUIEnabled: false;"
  >
    <a-assets>
      <a-asset-item id="m" src="city_pack_3.glb"></a-asset-item>
    </a-assets>

    <a-marker preset="hiro">
      <!-- remove scale attribute; JS will set it -->
      <a-entity id="model" gltf-model="#m" position="0 0 0"></a-entity>
    </a-marker>

    <a-entity camera></a-entity>
  </a-scene>

  <script>
    // How big you want the model’s largest dimension (in meters, relative to the marker).
    // Try 2–4 to start; 1 is usually small on a 1m marker.
    const DESIRED_SIZE = 3.0;

    // Optional extra multiplier if you just want it bigger/smaller without recalculating.
    const SCALE_MULTIPLIER = 1.0;

    const el = document.getElementById('model');
    el.addEventListener('model-loaded', (e) => {
      const THREE = AFRAME.THREE;
      const obj = e.detail.model;

      // Avoid culling & make sure world matrices are updated
      obj.traverse(o => { o.frustumCulled = false; if (o.geometry) o.geometry.computeBoundingBox?.(); });
      obj.updateMatrixWorld(true);

      // Compute bounds on the loaded object
      const box = new THREE.Box3().setFromObject(obj);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z) || 1e-6;

      // Uniform scale so the largest dimension matches DESIRED_SIZE
      const s = (DESIRED_SIZE / maxDim) * SCALE_MULTIPLIER;
      el.object3D.scale.setScalar(s);

      // Put the model’s base on the marker plane (y=0) and center it in X/Z
      // (box is in the model’s pre-scaled space, so multiply by s)
      const minY = box.min.y * s;
      const cx = center.x * s;
      const cz = center.z * s;
      el.object3D.position.set(-cx, -minY, -cz);

      // If orientation is off, you can rotate:
      // el.object3D.rotation.set(THREE.MathUtils.degToRad(-90), 0, 0);
    });

    el.addEventListener('model-error', (e) => console.error('Model failed to load:', e.detail));
  </script>
</body>
